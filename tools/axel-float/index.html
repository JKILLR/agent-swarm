<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Axel</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      background: rgba(20, 20, 25, 0.92);
      color: #fff;
      height: 100vh;
      display: flex;
      flex-direction: column;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Draggable title bar */
    .titlebar {
      -webkit-app-region: drag;
      height: 36px;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(147, 51, 234, 0.3));
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .titlebar-title {
      font-size: 13px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .titlebar-title::before {
      content: '⚡';
    }

    .titlebar-buttons {
      -webkit-app-region: no-drag;
      display: flex;
      gap: 8px;
    }

    .titlebar-btn {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .titlebar-btn:hover {
      opacity: 0.8;
    }

    .btn-minimize {
      background: #fbbf24;
    }

    .btn-close {
      background: #ef4444;
    }

    /* Messages area */
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 14px;
      line-height: 1.4;
      animation: fadeIn 0.2s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message.user {
      align-self: flex-end;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .message.assistant {
      align-self: flex-start;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.95);
      border-bottom-left-radius: 4px;
    }

    .message.system {
      align-self: center;
      background: rgba(59, 130, 246, 0.2);
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      padding: 6px 12px;
    }

    /* Typing indicator */
    .typing {
      display: flex;
      gap: 4px;
      padding: 12px 16px;
    }

    .typing span {
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .typing span:nth-child(1) { animation-delay: -0.32s; }
    .typing span:nth-child(2) { animation-delay: -0.16s; }

    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    /* Input area */
    .input-area {
      padding: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      gap: 8px;
    }

    #chat-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      padding: 10px 16px;
      color: white;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s;
    }

    #chat-input:focus {
      border-color: rgba(59, 130, 246, 0.5);
    }

    #chat-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #send-btn {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, opacity 0.2s;
    }

    #send-btn:hover {
      transform: scale(1.05);
    }

    #send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Connection status */
    .status {
      position: absolute;
      top: 42px;
      right: 12px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ef4444;
    }

    .status.connected {
      background: #22c55e;
    }

    /* Scrollbar */
    .messages::-webkit-scrollbar {
      width: 6px;
    }

    .messages::-webkit-scrollbar-track {
      background: transparent;
    }

    .messages::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="titlebar">
    <span class="titlebar-title">Axel</span>
    <div class="titlebar-buttons">
      <button class="titlebar-btn btn-minimize" id="minimize-btn" title="Hide (⌘⇧A to show)"></button>
      <button class="titlebar-btn btn-close" id="close-btn"></button>
    </div>
  </div>

  <div class="status" id="status"></div>

  <div class="messages" id="messages">
    <div class="message system">Connected to Axel • ⌘⇧A to toggle</div>
  </div>

  <div class="input-area">
    <input type="text" id="chat-input" placeholder="Ask Axel anything..." autocomplete="off">
    <button id="send-btn">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
      </svg>
    </button>
  </div>

  <script>
    const { ipcRenderer } = require('electron');

    const messagesDiv = document.getElementById('messages');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const statusDot = document.getElementById('status');

    let ws = null;
    let isTyping = false;
    let currentResponse = '';  // Track streamed content to avoid duplicates

    // Use a fixed session ID so floating window shares context with browser
    const SHARED_SESSION_ID = 'axel-shared-session';

    // Connect to backend WebSocket
    function connect() {
      ws = new WebSocket('ws://localhost:8000/ws/chat');

      ws.onopen = () => {
        statusDot.classList.add('connected');
        console.log('Connected to Axel backend');
      };

      ws.onclose = () => {
        statusDot.classList.remove('connected');
        console.log('Disconnected, reconnecting in 3s...');
        setTimeout(connect, 3000);
      };

      ws.onerror = (err) => {
        console.error('WebSocket error:', err);
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleMessage(data);
      };
    }

    function handleMessage(data) {
      console.log('[Axel Float] Event:', data.type, data);

      switch (data.type) {
        case 'chat_start':
          showTyping();
          currentResponse = '';
          break;

        case 'agent_start':
          showTyping();
          currentResponse = '';
          break;

        case 'agent_delta':
          // Stream content as it arrives
          removeTyping();
          if (data.delta) {
            currentResponse += data.delta;
            appendOrUpdateLastMessage(currentResponse, 'assistant');
          }
          break;

        case 'agent_complete':
          // Final content - use streamed content if available, otherwise use event content
          removeTyping();
          const finalContent = currentResponse || data.content || '';
          if (finalContent) {
            appendOrUpdateLastMessage(finalContent, 'assistant');
          }
          finalizeLastMessage();  // Mark as complete so next message creates new element
          currentResponse = '';
          break;

        case 'chat_complete':
          removeTyping();
          currentResponse = '';
          break;

        case 'error':
          removeTyping();
          addMessage('Error: ' + data.message, 'system');
          currentResponse = '';
          break;

        case 'proactive':
          // Proactive message from watcher
          addMessage(data.content, 'assistant');
          break;

        default:
          // Ignore other events (tool_start, thinking_*, etc.)
          break;
      }
    }

    function addMessage(text, type) {
      const msg = document.createElement('div');
      msg.className = `message ${type}`;
      msg.textContent = text;
      messagesDiv.appendChild(msg);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Update the last assistant message or create a new one
    function appendOrUpdateLastMessage(text, type) {
      // Find the last message that's being streamed (no 'complete' class)
      const lastMsg = messagesDiv.querySelector('.message.assistant.streaming');
      if (lastMsg) {
        lastMsg.textContent = text;  // Replace, not append (we're tracking full content)
      } else {
        // Create new streaming message
        const msg = document.createElement('div');
        msg.className = `message ${type} streaming`;
        msg.textContent = text;
        messagesDiv.appendChild(msg);
      }
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Mark streaming message as complete
    function finalizeLastMessage() {
      const streamingMsg = messagesDiv.querySelector('.message.streaming');
      if (streamingMsg) {
        streamingMsg.classList.remove('streaming');
      }
    }

    function showTyping() {
      if (isTyping) return;
      isTyping = true;
      const typing = document.createElement('div');
      typing.className = 'message assistant typing';
      typing.id = 'typing-indicator';
      typing.innerHTML = '<span></span><span></span><span></span>';
      messagesDiv.appendChild(typing);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function removeTyping() {
      isTyping = false;
      const typing = document.getElementById('typing-indicator');
      if (typing) typing.remove();
    }

    function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;

      addMessage(text, 'user');
      chatInput.value = '';
      showTyping();
      currentResponse = '';  // Reset for new response

      // Send with shared session ID so context is shared with browser
      ws.send(JSON.stringify({
        message: text,
        session_id: SHARED_SESSION_ID
      }));
    }

    // Event listeners
    sendBtn.addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    document.getElementById('minimize-btn').addEventListener('click', () => {
      ipcRenderer.send('minimize-window');
    });

    document.getElementById('close-btn').addEventListener('click', () => {
      ipcRenderer.send('close-window');
    });

    // Start connection
    connect();
  </script>
</body>
</html>
